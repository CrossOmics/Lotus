# Auto-generated by scripts/generate_scanpy_proxies.py
from __future__ import annotations

import inspect

import scanpy as _orig_module

__all__ = [
    "Neighbors",
    "Verbosity",
    "annotate_doc_types",
    "cplearn",
    "datasets",
    "experimental",
    "external",
    "get",
    "logging",
    "metrics",
    "neighbors",
    "pl",
    "plotting",
    "pp",
    "preprocessing",
    "queries",
    "read",
    "read_10x_h5",
    "read_10x_mtx",
    "read_visium",
    "readwrite",
    "settings",
    "sim_models",
    "deg",
    "scRNA_seq",  # Alias for backward compatibility
    "tl",
    "tools",
    "write"
]

from .methods import cplearn as cplearn

from .methods.scanpy import datasets as datasets

from .methods.scanpy import experimental as experimental

from .methods.scanpy import external as external

from .methods.scanpy import get as get

from .methods.scanpy import logging as logging

from .methods.scanpy import metrics as metrics

from .methods.scanpy import neighbors as neighbors

from .methods.scanpy import plotting as pl

from .methods.scanpy import plotting as plotting

from .methods.scanpy import preprocessing as pp

from .methods.scanpy import preprocessing as preprocessing

from .methods.scanpy import queries as queries

from .methods.scanpy import readwrite as readwrite

from .methods.scanpy import sim_models as sim_models

from .methods import deg as deg
from .methods import deg as scRNA_seq  # Alias for backward compatibility

from .methods.scanpy import tools as tl

from .methods.scanpy import tools as tools

class Neighbors(_orig_module.Neighbors):
    def __init__(self, adata: 'AnnData', *, n_dcs: 'int | None' = None, neighbors_key: 'str | None' = None):
        super().__init__(adata, n_dcs=n_dcs, neighbors_key=neighbors_key)

Verbosity = _orig_module.Verbosity  # Proxy alias for scanpy.Verbosity

def annotate_doc_types(mod: 'ModuleType', root: 'str', **_lotus_extras):
    _lotus_call_args = []
    _lotus_call_args.append(mod)
    _lotus_call_args.append(root)
    return _orig_module.annotate_doc_types(*_lotus_call_args, **_lotus_extras)

_read_cache_compression_default = inspect.signature(_orig_module.read).parameters['cache_compression'].default

def read(filename: 'Path | str', backed: "Literal['r', 'r+'] | None" = None, *, sheet: 'str | None' = None, ext: 'str | None' = None, delimiter: 'str | None' = None, first_column_names: 'bool' = False, backup_url: 'str | None' = None, cache: 'bool' = False, cache_compression: "Literal['gzip', 'lzf'] | None | Empty" = _read_cache_compression_default, **kwargs) -> 'AnnData':
    _lotus_kwargs = {}
    if sheet is not None:
        _lotus_kwargs['sheet'] = sheet
    if ext is not None:
        _lotus_kwargs['ext'] = ext
    if delimiter is not None:
        _lotus_kwargs['delimiter'] = delimiter
    if first_column_names != False:
        _lotus_kwargs['first_column_names'] = first_column_names
    if backup_url is not None:
        _lotus_kwargs['backup_url'] = backup_url
    if cache != False:
        _lotus_kwargs['cache'] = cache
    if cache_compression is not _read_cache_compression_default:
        _lotus_kwargs['cache_compression'] = cache_compression
    _lotus_kwargs.update(kwargs)
    return _orig_module.read(filename, backed, **_lotus_kwargs)

def read_10x_h5(filename: 'Path | str' = None, *, genome: 'str | None' = None, gex_only: 'bool' = True, backup_url: 'str | None' = None, **_lotus_extras) -> 'AnnData':
    _lotus_kwargs = {}
    if genome is not None:
        _lotus_kwargs['genome'] = genome
    if gex_only != True:
        _lotus_kwargs['gex_only'] = gex_only
    if backup_url is not None:
        _lotus_kwargs['backup_url'] = backup_url
    _lotus_call_args = []
    if filename is not None:
        _lotus_call_args.append(filename)
    return _orig_module.read_10x_h5(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

_read_10x_mtx_cache_compression_default = inspect.signature(_orig_module.read_10x_mtx).parameters['cache_compression'].default

def read_10x_mtx(path: 'Path | str' = None, *, var_names: "Literal['gene_symbols', 'gene_ids']" = 'gene_symbols', make_unique: 'bool' = True, cache: 'bool' = False, cache_compression: "Literal['gzip', 'lzf'] | None | Empty" = _read_10x_mtx_cache_compression_default, gex_only: 'bool' = True, prefix: 'str | None' = None, **_lotus_extras) -> 'AnnData':
    _lotus_kwargs = {}
    if var_names != 'gene_symbols':
        _lotus_kwargs['var_names'] = var_names
    if make_unique != True:
        _lotus_kwargs['make_unique'] = make_unique
    if cache != False:
        _lotus_kwargs['cache'] = cache
    if cache_compression is not _read_10x_mtx_cache_compression_default:
        _lotus_kwargs['cache_compression'] = cache_compression
    if gex_only != True:
        _lotus_kwargs['gex_only'] = gex_only
    if prefix is not None:
        _lotus_kwargs['prefix'] = prefix
    _lotus_call_args = []
    if path is not None:
        _lotus_call_args.append(path)
    return _orig_module.read_10x_mtx(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def read_visium(path: 'Path | str' = None, genome: 'str | None' = None, *, count_file: 'str' = 'filtered_feature_bc_matrix.h5', library_id: 'str | None' = None, load_images: 'bool | None' = True, source_image_path: 'Path | str | None' = None, **_lotus_extras) -> 'AnnData':
    _lotus_kwargs = {}
    if count_file != 'filtered_feature_bc_matrix.h5':
        _lotus_kwargs['count_file'] = count_file
    if library_id is not None:
        _lotus_kwargs['library_id'] = library_id
    if load_images != True:
        _lotus_kwargs['load_images'] = load_images
    if source_image_path is not None:
        _lotus_kwargs['source_image_path'] = source_image_path
    _lotus_call_args = []
    if path is not None:
        _lotus_call_args.append(path)
    _lotus_call_args.append(genome)
    return _orig_module.read_visium(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

class settings(_orig_module.settings):
    def __init__(self, /, *args, **kwargs):
        super().__init__(*args, **kwargs)

def write(filename: 'Path | str', adata: 'AnnData', *, ext: "Literal['h5', 'csv', 'txt', 'npz'] | None" = None, compression: "Literal['gzip', 'lzf'] | None" = 'gzip', compression_opts: 'int | None' = None, **_lotus_extras):
    _lotus_kwargs = {}
    if ext is not None:
        _lotus_kwargs['ext'] = ext
    if compression != 'gzip':
        _lotus_kwargs['compression'] = compression
    if compression_opts is not None:
        _lotus_kwargs['compression_opts'] = compression_opts
    _lotus_call_args = []
    _lotus_call_args.append(filename)
    _lotus_call_args.append(adata)
    return _orig_module.write(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def __getattr__(name: str):
    try:
        return getattr(_orig_module, name)
    except AttributeError as exc:
        raise AttributeError(f"scanpy has no attribute {name!r}") from exc

def __dir__():
    return sorted(set(__all__) | {name for name in dir(_orig_module) if not name.startswith('__')})
