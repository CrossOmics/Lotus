# Auto-generated by scripts/generate_scanpy_proxies.py
from __future__ import annotations

import inspect

import scanpy.external.pp as _orig_module

__all__ = [
    "bbknn",
    "dca",
    "harmony_integrate",
    "hashsolo",
    "magic",
    "mnn_correct",
    "scanorama_integrate",
    "scrublet",
    "scrublet_simulate_doublets"
]

def bbknn(adata: 'AnnData', *, batch_key: 'str' = 'batch', use_rep: 'str' = 'X_pca', approx: 'bool' = True, use_annoy: 'bool' = True, metric: 'str | Callable | DistanceMetric' = 'euclidean', copy: 'bool' = False, neighbors_within_batch: 'int' = 3, n_pcs: 'int' = 50, trim: 'int | None' = None, annoy_n_trees: 'int' = 10, pynndescent_n_neighbors: 'int' = 30, pynndescent_random_state: 'int' = 0, use_faiss: 'bool' = True, set_op_mix_ratio: 'float' = 1.0, local_connectivity: 'int' = 1, **kwargs) -> 'AnnData | None':
    _lotus_kwargs = {}
    if batch_key != 'batch':
        _lotus_kwargs['batch_key'] = batch_key
    if use_rep != 'X_pca':
        _lotus_kwargs['use_rep'] = use_rep
    if approx != True:
        _lotus_kwargs['approx'] = approx
    if use_annoy != True:
        _lotus_kwargs['use_annoy'] = use_annoy
    if metric != 'euclidean':
        _lotus_kwargs['metric'] = metric
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if neighbors_within_batch != 3:
        _lotus_kwargs['neighbors_within_batch'] = neighbors_within_batch
    if n_pcs != 50:
        _lotus_kwargs['n_pcs'] = n_pcs
    if trim is not None:
        _lotus_kwargs['trim'] = trim
    if annoy_n_trees != 10:
        _lotus_kwargs['annoy_n_trees'] = annoy_n_trees
    if pynndescent_n_neighbors != 30:
        _lotus_kwargs['pynndescent_n_neighbors'] = pynndescent_n_neighbors
    if pynndescent_random_state != 0:
        _lotus_kwargs['pynndescent_random_state'] = pynndescent_random_state
    if use_faiss != True:
        _lotus_kwargs['use_faiss'] = use_faiss
    if set_op_mix_ratio != 1.0:
        _lotus_kwargs['set_op_mix_ratio'] = set_op_mix_ratio
    if local_connectivity != 1:
        _lotus_kwargs['local_connectivity'] = local_connectivity
    _lotus_kwargs.update(kwargs)
    return _orig_module.bbknn(adata, **_lotus_kwargs)

_dca_network_kwds_default = inspect.signature(_orig_module.dca).parameters['network_kwds'].default
_dca_training_kwds_default = inspect.signature(_orig_module.dca).parameters['training_kwds'].default

def dca(adata: 'AnnData' = None, mode: "Literal['denoise', 'latent']" = 'denoise', *, ae_type: '_AEType' = 'nb-conddisp', normalize_per_cell: 'bool' = True, scale: 'bool' = True, log1p: 'bool' = True, hidden_size: 'Sequence[int]' = (64, 32, 64), hidden_dropout: 'float | Sequence[float]' = 0.0, batchnorm: 'bool' = True, activation: 'str' = 'relu', init: 'str' = 'glorot_uniform', network_kwds: 'Mapping[str, Any]' = _dca_network_kwds_default, epochs: 'int' = 300, reduce_lr: 'int' = 10, early_stop: 'int' = 15, batch_size: 'int' = 32, optimizer: 'str' = 'RMSprop', random_state: '_LegacyRandom' = 0, threads: 'int | None' = None, learning_rate: 'float | None' = None, verbose: 'bool' = False, training_kwds: 'Mapping[str, Any]' = _dca_training_kwds_default, return_model: 'bool' = False, return_info: 'bool' = False, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if ae_type != 'nb-conddisp':
        _lotus_kwargs['ae_type'] = ae_type
    if normalize_per_cell != True:
        _lotus_kwargs['normalize_per_cell'] = normalize_per_cell
    if scale != True:
        _lotus_kwargs['scale'] = scale
    if log1p != True:
        _lotus_kwargs['log1p'] = log1p
    if hidden_size != (64, 32, 64):
        _lotus_kwargs['hidden_size'] = hidden_size
    if hidden_dropout != 0.0:
        _lotus_kwargs['hidden_dropout'] = hidden_dropout
    if batchnorm != True:
        _lotus_kwargs['batchnorm'] = batchnorm
    if activation != 'relu':
        _lotus_kwargs['activation'] = activation
    if init != 'glorot_uniform':
        _lotus_kwargs['init'] = init
    if network_kwds is not _dca_network_kwds_default:
        _lotus_kwargs['network_kwds'] = network_kwds
    if epochs != 300:
        _lotus_kwargs['epochs'] = epochs
    if reduce_lr != 10:
        _lotus_kwargs['reduce_lr'] = reduce_lr
    if early_stop != 15:
        _lotus_kwargs['early_stop'] = early_stop
    if batch_size != 32:
        _lotus_kwargs['batch_size'] = batch_size
    if optimizer != 'RMSprop':
        _lotus_kwargs['optimizer'] = optimizer
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if threads is not None:
        _lotus_kwargs['threads'] = threads
    if learning_rate is not None:
        _lotus_kwargs['learning_rate'] = learning_rate
    if verbose != False:
        _lotus_kwargs['verbose'] = verbose
    if training_kwds is not _dca_training_kwds_default:
        _lotus_kwargs['training_kwds'] = training_kwds
    if return_model != False:
        _lotus_kwargs['return_model'] = return_model
    if return_info != False:
        _lotus_kwargs['return_info'] = return_info
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(mode)
    return _orig_module.dca(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def harmony_integrate(adata: 'AnnData', key: 'str | Sequence[str]', *, basis: 'str' = 'X_pca', adjusted_basis: 'str' = 'X_pca_harmony', **kwargs):
    _lotus_kwargs = {}
    if basis != 'X_pca':
        _lotus_kwargs['basis'] = basis
    if adjusted_basis != 'X_pca_harmony':
        _lotus_kwargs['adjusted_basis'] = adjusted_basis
    _lotus_kwargs.update(kwargs)
    return _orig_module.harmony_integrate(adata, key, **_lotus_kwargs)

def hashsolo(adata: 'AnnData', cell_hashing_columns: 'Sequence[str]', *, priors: 'tuple[float, float, float]' = (0.01, 0.8, 0.19), pre_existing_clusters: 'str | None' = None, number_of_noise_barcodes: 'int | None' = None, inplace: 'bool' = True, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if priors != (0.01, 0.8, 0.19):
        _lotus_kwargs['priors'] = priors
    if pre_existing_clusters is not None:
        _lotus_kwargs['pre_existing_clusters'] = pre_existing_clusters
    if number_of_noise_barcodes is not None:
        _lotus_kwargs['number_of_noise_barcodes'] = number_of_noise_barcodes
    if inplace != True:
        _lotus_kwargs['inplace'] = inplace
    _lotus_call_args = []
    _lotus_call_args.append(adata)
    _lotus_call_args.append(cell_hashing_columns)
    return _orig_module.hashsolo(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def magic(adata: 'AnnData', name_list: "Literal['all_genes', 'pca_only'] | Sequence[str] | None" = None, *, knn: 'int' = 5, decay: 'float | None' = 1, knn_max: 'int | None' = None, t: "Literal['auto'] | int" = 3, n_pca: 'int | None' = 100, solver: "Literal['exact', 'approximate']" = 'exact', knn_dist: 'str' = 'euclidean', random_state: '_LegacyRandom' = None, n_jobs: 'int | None' = None, verbose: 'bool' = False, copy: 'bool | None' = None, **kwargs) -> 'AnnData | None':
    _lotus_kwargs = {}
    if knn != 5:
        _lotus_kwargs['knn'] = knn
    if decay != 1:
        _lotus_kwargs['decay'] = decay
    if knn_max is not None:
        _lotus_kwargs['knn_max'] = knn_max
    if t != 3:
        _lotus_kwargs['t'] = t
    if n_pca != 100:
        _lotus_kwargs['n_pca'] = n_pca
    if solver != 'exact':
        _lotus_kwargs['solver'] = solver
    if knn_dist != 'euclidean':
        _lotus_kwargs['knn_dist'] = knn_dist
    if random_state is not None:
        _lotus_kwargs['random_state'] = random_state
    if n_jobs is not None:
        _lotus_kwargs['n_jobs'] = n_jobs
    if verbose != False:
        _lotus_kwargs['verbose'] = verbose
    if copy is not None:
        _lotus_kwargs['copy'] = copy
    _lotus_kwargs.update(kwargs)
    return _orig_module.magic(adata, name_list, **_lotus_kwargs)

def mnn_correct(*datas: 'AnnData | np.ndarray', var_index: 'Collection[str] | None' = None, var_subset: 'Collection[str] | None' = None, batch_key: 'str' = 'batch', index_unique: 'str' = '-', batch_categories: 'Collection[Any] | None' = None, k: 'int' = 20, sigma: 'float' = 1.0, cos_norm_in: 'bool' = True, cos_norm_out: 'bool' = True, svd_dim: 'int | None' = None, var_adj: 'bool' = True, compute_angle: 'bool' = False, mnn_order: 'Sequence[int] | None' = None, svd_mode: "Literal['svd', 'rsvd', 'irlb']" = 'rsvd', do_concatenate: 'bool' = True, save_raw: 'bool' = False, n_jobs: 'int | None' = None, **kwargs) -> 'tuple[np.ndarray | AnnData, list[pd.DataFrame], list[tuple[float | None, int]] | None]':
    _lotus_kwargs = {}
    if var_index is not None:
        _lotus_kwargs['var_index'] = var_index
    if var_subset is not None:
        _lotus_kwargs['var_subset'] = var_subset
    if batch_key != 'batch':
        _lotus_kwargs['batch_key'] = batch_key
    if index_unique != '-':
        _lotus_kwargs['index_unique'] = index_unique
    if batch_categories is not None:
        _lotus_kwargs['batch_categories'] = batch_categories
    if k != 20:
        _lotus_kwargs['k'] = k
    if sigma != 1.0:
        _lotus_kwargs['sigma'] = sigma
    if cos_norm_in != True:
        _lotus_kwargs['cos_norm_in'] = cos_norm_in
    if cos_norm_out != True:
        _lotus_kwargs['cos_norm_out'] = cos_norm_out
    if svd_dim is not None:
        _lotus_kwargs['svd_dim'] = svd_dim
    if var_adj != True:
        _lotus_kwargs['var_adj'] = var_adj
    if compute_angle != False:
        _lotus_kwargs['compute_angle'] = compute_angle
    if mnn_order is not None:
        _lotus_kwargs['mnn_order'] = mnn_order
    if svd_mode != 'rsvd':
        _lotus_kwargs['svd_mode'] = svd_mode
    if do_concatenate != True:
        _lotus_kwargs['do_concatenate'] = do_concatenate
    if save_raw != False:
        _lotus_kwargs['save_raw'] = save_raw
    if n_jobs is not None:
        _lotus_kwargs['n_jobs'] = n_jobs
    _lotus_kwargs.update(kwargs)
    return _orig_module.mnn_correct(*datas, **_lotus_kwargs)

def scanorama_integrate(adata: 'AnnData', key: 'str', *, basis: 'str' = 'X_pca', adjusted_basis: 'str' = 'X_scanorama', knn: 'int' = 20, sigma: 'float' = 15, approx: 'bool' = True, alpha: 'float' = 0.1, batch_size: 'int' = 5000, **kwargs) -> 'None':
    _lotus_kwargs = {}
    if basis != 'X_pca':
        _lotus_kwargs['basis'] = basis
    if adjusted_basis != 'X_scanorama':
        _lotus_kwargs['adjusted_basis'] = adjusted_basis
    if knn != 20:
        _lotus_kwargs['knn'] = knn
    if sigma != 15:
        _lotus_kwargs['sigma'] = sigma
    if approx != True:
        _lotus_kwargs['approx'] = approx
    if alpha != 0.1:
        _lotus_kwargs['alpha'] = alpha
    if batch_size != 5000:
        _lotus_kwargs['batch_size'] = batch_size
    _lotus_kwargs.update(kwargs)
    return _orig_module.scanorama_integrate(adata, key, **_lotus_kwargs)

def scrublet(adata: 'AnnData' = None, adata_sim: 'AnnData | None' = None, *, batch_key: 'str | None' = None, sim_doublet_ratio: 'float' = 2.0, expected_doublet_rate: 'float' = 0.05, stdev_doublet_rate: 'float' = 0.02, synthetic_doublet_umi_subsampling: 'float' = 1.0, knn_dist_metric: '_Metric | _MetricFn' = 'euclidean', normalize_variance: 'bool' = True, log_transform: 'bool' = False, mean_center: 'bool' = True, n_prin_comps: 'int' = 30, use_approx_neighbors: 'bool | None' = None, get_doublet_neighbor_parents: 'bool' = False, n_neighbors: 'int | None' = None, threshold: 'float | None' = None, verbose: 'bool' = True, copy: 'bool' = False, random_state: '_LegacyRandom' = 0, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if batch_key is not None:
        _lotus_kwargs['batch_key'] = batch_key
    if sim_doublet_ratio != 2.0:
        _lotus_kwargs['sim_doublet_ratio'] = sim_doublet_ratio
    if expected_doublet_rate != 0.05:
        _lotus_kwargs['expected_doublet_rate'] = expected_doublet_rate
    if stdev_doublet_rate != 0.02:
        _lotus_kwargs['stdev_doublet_rate'] = stdev_doublet_rate
    if synthetic_doublet_umi_subsampling != 1.0:
        _lotus_kwargs['synthetic_doublet_umi_subsampling'] = synthetic_doublet_umi_subsampling
    if knn_dist_metric != 'euclidean':
        _lotus_kwargs['knn_dist_metric'] = knn_dist_metric
    if normalize_variance != True:
        _lotus_kwargs['normalize_variance'] = normalize_variance
    if log_transform != False:
        _lotus_kwargs['log_transform'] = log_transform
    if mean_center != True:
        _lotus_kwargs['mean_center'] = mean_center
    if n_prin_comps != 30:
        _lotus_kwargs['n_prin_comps'] = n_prin_comps
    if use_approx_neighbors is not None:
        _lotus_kwargs['use_approx_neighbors'] = use_approx_neighbors
    if get_doublet_neighbor_parents != False:
        _lotus_kwargs['get_doublet_neighbor_parents'] = get_doublet_neighbor_parents
    if n_neighbors is not None:
        _lotus_kwargs['n_neighbors'] = n_neighbors
    if threshold is not None:
        _lotus_kwargs['threshold'] = threshold
    if verbose != True:
        _lotus_kwargs['verbose'] = verbose
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(adata_sim)
    return _orig_module.scrublet(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def scrublet_simulate_doublets(adata: 'AnnData' = None, *, layer: 'str | None' = None, sim_doublet_ratio: 'float' = 2.0, synthetic_doublet_umi_subsampling: 'float' = 1.0, random_seed: '_LegacyRandom' = 0, **_lotus_extras) -> 'AnnData':
    _lotus_kwargs = {}
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if sim_doublet_ratio != 2.0:
        _lotus_kwargs['sim_doublet_ratio'] = sim_doublet_ratio
    if synthetic_doublet_umi_subsampling != 1.0:
        _lotus_kwargs['synthetic_doublet_umi_subsampling'] = synthetic_doublet_umi_subsampling
    if random_seed != 0:
        _lotus_kwargs['random_seed'] = random_seed
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.scrublet_simulate_doublets(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def __getattr__(name: str):
    try:
        return getattr(_orig_module, name)
    except AttributeError as exc:
        raise AttributeError(f"scanpy.external.pp has no attribute {name!r}") from exc

def __dir__():
    return sorted(set(__all__) | {name for name in dir(_orig_module) if not name.startswith('__')})
