# Auto-generated by scripts/generate_scanpy_proxies.py
from __future__ import annotations

import inspect

import scanpy.neighbors as _orig_module

__all__ = [
    "FlatTree",
    "KwdsForTransformer",
    "Neighbors",
    "NeighborsParams",
    "NeighborsView",
    "OnFlySymMatrix",
    "get_literal_vals",
    "neighbors",
    "settings"
]

class FlatTree(_orig_module.FlatTree):
    def __init__(self, /, *args, **kwargs):
        super().__init__(*args, **kwargs)

class KwdsForTransformer(_orig_module.KwdsForTransformer):
    def __init__(self, /, *args, **kwargs):
        super().__init__(*args, **kwargs)

class Neighbors(_orig_module.Neighbors):
    def __init__(self, adata: 'AnnData', *, n_dcs: 'int | None' = None, neighbors_key: 'str | None' = None):
        super().__init__(adata, n_dcs=n_dcs, neighbors_key=neighbors_key)

class NeighborsParams(_orig_module.NeighborsParams):
    def __init__(self, /, *args, **kwargs):
        super().__init__(*args, **kwargs)

class NeighborsView(_orig_module.NeighborsView):
    def __init__(self, adata: 'AnnData', key=None):
        super().__init__(adata, key)

class OnFlySymMatrix(_orig_module.OnFlySymMatrix):
    def __init__(self, get_row: 'Callable[[Any], np.ndarray]', shape: 'tuple[int, int]', *, rows: 'MutableMapping[Any, np.ndarray] | None' = None, restrict_array: 'np.ndarray | None' = None):
        super().__init__(get_row, shape, rows=rows, restrict_array=restrict_array)

def get_literal_vals(typ: 'UnionType | Any' = None, **_lotus_extras) -> 'KeysView[Any]':
    _lotus_call_args = []
    if typ is not None:
        _lotus_call_args.append(typ)
    return _orig_module.get_literal_vals(*_lotus_call_args, **_lotus_extras)

_neighbors_metric_kwds_default = inspect.signature(_orig_module.neighbors).parameters['metric_kwds'].default

def neighbors(adata: 'AnnData' = None, n_neighbors: 'int' = 15, n_pcs: 'int | None' = None, *, use_rep: 'str | None' = None, knn: 'bool' = True, method: '_Method' = 'umap', transformer: 'KnnTransformerLike | _KnownTransformer | None' = None, metric: '_Metric | _MetricFn' = 'euclidean', metric_kwds: 'Mapping[str, Any]' = _neighbors_metric_kwds_default, random_state: '_LegacyRandom' = 0, key_added: 'str | None' = None, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if use_rep is not None:
        _lotus_kwargs['use_rep'] = use_rep
    if knn != True:
        _lotus_kwargs['knn'] = knn
    if method != 'umap':
        _lotus_kwargs['method'] = method
    if transformer is not None:
        _lotus_kwargs['transformer'] = transformer
    if metric != 'euclidean':
        _lotus_kwargs['metric'] = metric
    if metric_kwds is not _neighbors_metric_kwds_default:
        _lotus_kwargs['metric_kwds'] = metric_kwds
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(n_neighbors)
    _lotus_call_args.append(n_pcs)
    return _orig_module.neighbors(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

class settings(_orig_module.settings):
    def __init__(self, /, *args, **kwargs):
        super().__init__(*args, **kwargs)

def __getattr__(name: str):
    try:
        return getattr(_orig_module, name)
    except AttributeError as exc:
        raise AttributeError(f"scanpy.neighbors has no attribute {name!r}") from exc

def __dir__():
    return sorted(set(__all__) | {name for name in dir(_orig_module) if not name.startswith('__')})
