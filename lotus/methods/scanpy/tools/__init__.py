# Auto-generated by scripts/generate_scanpy_proxies.py
from __future__ import annotations

import inspect

import scanpy.tools as _orig_module

__all__ = [
    "Ingest",
    "dendrogram",
    "diffmap",
    "dpt",
    "draw_graph",
    "embedding_density",
    "filter_rank_genes_groups",
    "ingest",
    "leiden",
    "louvain",
    "marker_gene_overlap",
    "paga",
    "paga_compare_paths",
    "paga_degrees",
    "paga_expression_entropies",
    "rank_genes_groups",
    "score_genes",
    "score_genes_cell_cycle",
    "sim",
    "tsne",
    "umap"
]

class Ingest(_orig_module.Ingest):
    def __init__(self, adata: 'AnnData', neighbors_key: 'str | None' = None):
        super().__init__(adata, neighbors_key)

def dendrogram(adata: 'AnnData', groupby: 'str | Sequence[str]', *, n_pcs: 'int | None' = None, use_rep: 'str | None' = None, var_names: 'Sequence[str] | None' = None, use_raw: 'bool | None' = None, cor_method: 'str' = 'pearson', linkage_method: 'str' = 'complete', optimal_ordering: 'bool' = False, key_added: 'str | None' = None, inplace: 'bool' = True, **_lotus_extras) -> 'dict[str, Any] | None':
    _lotus_kwargs = {}
    if n_pcs is not None:
        _lotus_kwargs['n_pcs'] = n_pcs
    if use_rep is not None:
        _lotus_kwargs['use_rep'] = use_rep
    if var_names is not None:
        _lotus_kwargs['var_names'] = var_names
    if use_raw is not None:
        _lotus_kwargs['use_raw'] = use_raw
    if cor_method != 'pearson':
        _lotus_kwargs['cor_method'] = cor_method
    if linkage_method != 'complete':
        _lotus_kwargs['linkage_method'] = linkage_method
    if optimal_ordering != False:
        _lotus_kwargs['optimal_ordering'] = optimal_ordering
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if inplace != True:
        _lotus_kwargs['inplace'] = inplace
    _lotus_call_args = []
    _lotus_call_args.append(adata)
    _lotus_call_args.append(groupby)
    return _orig_module.dendrogram(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def diffmap(adata: 'AnnData' = None, n_comps: 'int' = 15, *, neighbors_key: 'str | None' = None, random_state: '_LegacyRandom' = 0, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if neighbors_key is not None:
        _lotus_kwargs['neighbors_key'] = neighbors_key
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(n_comps)
    return _orig_module.diffmap(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def dpt(adata: 'AnnData' = None, n_dcs: 'int' = 10, *, n_branchings: 'int' = 0, min_group_size: 'float' = 0.01, allow_kendall_tau_shift: 'bool' = True, neighbors_key: 'str | None' = None, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if n_branchings != 0:
        _lotus_kwargs['n_branchings'] = n_branchings
    if min_group_size != 0.01:
        _lotus_kwargs['min_group_size'] = min_group_size
    if allow_kendall_tau_shift != True:
        _lotus_kwargs['allow_kendall_tau_shift'] = allow_kendall_tau_shift
    if neighbors_key is not None:
        _lotus_kwargs['neighbors_key'] = neighbors_key
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(n_dcs)
    return _orig_module.dpt(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def draw_graph(adata: 'AnnData', layout: '_Layout' = 'fa', *, init_pos: 'str | bool | None' = None, root: 'int | None' = None, random_state: '_LegacyRandom' = 0, n_jobs: 'int | None' = None, adjacency: 'SpBase | None' = None, key_added_ext: 'str | None' = None, neighbors_key: 'str | None' = None, obsp: 'str | None' = None, copy: 'bool' = False, **kwds) -> 'AnnData | None':
    _lotus_kwargs = {}
    if init_pos is not None:
        _lotus_kwargs['init_pos'] = init_pos
    if root is not None:
        _lotus_kwargs['root'] = root
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if n_jobs is not None:
        _lotus_kwargs['n_jobs'] = n_jobs
    if adjacency is not None:
        _lotus_kwargs['adjacency'] = adjacency
    if key_added_ext is not None:
        _lotus_kwargs['key_added_ext'] = key_added_ext
    if neighbors_key is not None:
        _lotus_kwargs['neighbors_key'] = neighbors_key
    if obsp is not None:
        _lotus_kwargs['obsp'] = obsp
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_kwargs.update(kwds)
    return _orig_module.draw_graph(adata, layout, **_lotus_kwargs)

def embedding_density(adata: 'AnnData' = None, basis: 'str' = 'umap', *, groupby: 'str | None' = None, key_added: 'str | None' = None, components: 'str | Sequence[str] | None' = None, **_lotus_extras) -> 'None':
    _lotus_kwargs = {}
    if groupby is not None:
        _lotus_kwargs['groupby'] = groupby
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if components is not None:
        _lotus_kwargs['components'] = components
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(basis)
    return _orig_module.embedding_density(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def filter_rank_genes_groups(adata: 'AnnData' = None, *, key: 'str | None' = None, groupby: 'str | None' = None, use_raw: 'bool | None' = None, key_added: 'str' = 'rank_genes_groups_filtered', min_in_group_fraction: 'float' = 0.25, min_fold_change: 'float' = 1, max_out_group_fraction: 'float' = 0.5, compare_abs: 'bool' = False, **_lotus_extras) -> 'None':
    _lotus_kwargs = {}
    if key is not None:
        _lotus_kwargs['key'] = key
    if groupby is not None:
        _lotus_kwargs['groupby'] = groupby
    if use_raw is not None:
        _lotus_kwargs['use_raw'] = use_raw
    if key_added != 'rank_genes_groups_filtered':
        _lotus_kwargs['key_added'] = key_added
    if min_in_group_fraction != 0.25:
        _lotus_kwargs['min_in_group_fraction'] = min_in_group_fraction
    if min_fold_change != 1:
        _lotus_kwargs['min_fold_change'] = min_fold_change
    if max_out_group_fraction != 0.5:
        _lotus_kwargs['max_out_group_fraction'] = max_out_group_fraction
    if compare_abs != False:
        _lotus_kwargs['compare_abs'] = compare_abs
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.filter_rank_genes_groups(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def ingest(adata: 'AnnData', adata_ref: 'AnnData', *, obs: 'str | Iterable[str] | None' = None, embedding_method: 'str | Iterable[str]' = ('umap', 'pca'), labeling_method: 'str' = 'knn', neighbors_key: 'str | None' = None, inplace: 'bool' = True, **kwargs):
    _lotus_kwargs = {}
    if obs is not None:
        _lotus_kwargs['obs'] = obs
    if embedding_method != ('umap', 'pca'):
        _lotus_kwargs['embedding_method'] = embedding_method
    if labeling_method != 'knn':
        _lotus_kwargs['labeling_method'] = labeling_method
    if neighbors_key is not None:
        _lotus_kwargs['neighbors_key'] = neighbors_key
    if inplace != True:
        _lotus_kwargs['inplace'] = inplace
    _lotus_kwargs.update(kwargs)
    return _orig_module.ingest(adata, adata_ref, **_lotus_kwargs)

def leiden(adata: 'AnnData', resolution: 'float' = 1, *, restrict_to: 'tuple[str, Sequence[str]] | None' = None, random_state: '_LegacyRandom' = 0, key_added: 'str' = 'leiden', adjacency: 'CSBase | None' = None, directed: 'bool | None' = None, use_weights: 'bool' = True, n_iterations: 'int' = -1, partition_type: 'type[MutableVertexPartition] | None' = None, neighbors_key: 'str | None' = None, obsp: 'str | None' = None, copy: 'bool' = False, flavor: "Literal['leidenalg', 'igraph']" = 'leidenalg', **clustering_args) -> 'AnnData | None':
    _lotus_kwargs = {}
    if restrict_to is not None:
        _lotus_kwargs['restrict_to'] = restrict_to
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if key_added != 'leiden':
        _lotus_kwargs['key_added'] = key_added
    if adjacency is not None:
        _lotus_kwargs['adjacency'] = adjacency
    if directed is not None:
        _lotus_kwargs['directed'] = directed
    if use_weights != True:
        _lotus_kwargs['use_weights'] = use_weights
    if n_iterations != -1:
        _lotus_kwargs['n_iterations'] = n_iterations
    if partition_type is not None:
        _lotus_kwargs['partition_type'] = partition_type
    if neighbors_key is not None:
        _lotus_kwargs['neighbors_key'] = neighbors_key
    if obsp is not None:
        _lotus_kwargs['obsp'] = obsp
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if flavor != 'leidenalg':
        _lotus_kwargs['flavor'] = flavor
    _lotus_kwargs.update(clustering_args)
    return _orig_module.leiden(adata, resolution, **_lotus_kwargs)

_louvain_partition_kwargs_default = inspect.signature(_orig_module.louvain).parameters['partition_kwargs'].default

def louvain(adata: 'AnnData' = None, resolution: 'float | None' = None, *, random_state: '_LegacyRandom' = 0, restrict_to: 'tuple[str, Sequence[str]] | None' = None, key_added: 'str' = 'louvain', adjacency: 'CSBase | None' = None, flavor: "Literal['vtraag', 'igraph', 'rapids']" = 'vtraag', directed: 'bool' = True, use_weights: 'bool' = False, partition_type: 'type[MutableVertexPartition] | None' = None, partition_kwargs: 'Mapping[str, Any]' = _louvain_partition_kwargs_default, neighbors_key: 'str | None' = None, obsp: 'str | None' = None, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if restrict_to is not None:
        _lotus_kwargs['restrict_to'] = restrict_to
    if key_added != 'louvain':
        _lotus_kwargs['key_added'] = key_added
    if adjacency is not None:
        _lotus_kwargs['adjacency'] = adjacency
    if flavor != 'vtraag':
        _lotus_kwargs['flavor'] = flavor
    if directed != True:
        _lotus_kwargs['directed'] = directed
    if use_weights != False:
        _lotus_kwargs['use_weights'] = use_weights
    if partition_type is not None:
        _lotus_kwargs['partition_type'] = partition_type
    if partition_kwargs is not _louvain_partition_kwargs_default:
        _lotus_kwargs['partition_kwargs'] = partition_kwargs
    if neighbors_key is not None:
        _lotus_kwargs['neighbors_key'] = neighbors_key
    if obsp is not None:
        _lotus_kwargs['obsp'] = obsp
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(resolution)
    return _orig_module.louvain(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def marker_gene_overlap(adata: 'AnnData', reference_markers: 'dict[str, set] | dict[str, list]', *, key: 'str' = 'rank_genes_groups', method: '_Method' = 'overlap_count', normalize: "Literal['reference', 'data'] | None" = None, top_n_markers: 'int | None' = None, adj_pval_threshold: 'float | None' = None, key_added: 'str' = 'marker_gene_overlap', inplace: 'bool' = False, **_lotus_extras):
    _lotus_kwargs = {}
    if key != 'rank_genes_groups':
        _lotus_kwargs['key'] = key
    if method != 'overlap_count':
        _lotus_kwargs['method'] = method
    if normalize is not None:
        _lotus_kwargs['normalize'] = normalize
    if top_n_markers is not None:
        _lotus_kwargs['top_n_markers'] = top_n_markers
    if adj_pval_threshold is not None:
        _lotus_kwargs['adj_pval_threshold'] = adj_pval_threshold
    if key_added != 'marker_gene_overlap':
        _lotus_kwargs['key_added'] = key_added
    if inplace != False:
        _lotus_kwargs['inplace'] = inplace
    _lotus_call_args = []
    _lotus_call_args.append(adata)
    _lotus_call_args.append(reference_markers)
    return _orig_module.marker_gene_overlap(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def paga(adata: 'AnnData' = None, groups: 'str | None' = None, *, use_rna_velocity: 'bool' = False, model: "Literal['v1.2', 'v1.0']" = 'v1.2', neighbors_key: 'str | None' = None, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if use_rna_velocity != False:
        _lotus_kwargs['use_rna_velocity'] = use_rna_velocity
    if model != 'v1.2':
        _lotus_kwargs['model'] = model
    if neighbors_key is not None:
        _lotus_kwargs['neighbors_key'] = neighbors_key
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(groups)
    return _orig_module.paga(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def paga_compare_paths(adata1: 'AnnData', adata2: 'AnnData', adjacency_key: 'str' = 'connectivities', adjacency_key2: 'str | None' = None, **_lotus_extras) -> 'PAGAComparePathsResult':
    _lotus_call_args = []
    _lotus_call_args.append(adata1)
    _lotus_call_args.append(adata2)
    _lotus_call_args.append(adjacency_key)
    _lotus_call_args.append(adjacency_key2)
    return _orig_module.paga_compare_paths(*_lotus_call_args, **_lotus_extras)

def paga_degrees(adata: 'AnnData' = None, **_lotus_extras) -> 'list[int]':
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.paga_degrees(*_lotus_call_args, **_lotus_extras)

def paga_expression_entropies(adata: 'AnnData' = None, **_lotus_extras) -> 'list[float]':
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.paga_expression_entropies(*_lotus_call_args, **_lotus_extras)

def rank_genes_groups(adata: 'AnnData', groupby: 'str', *, mask_var: 'NDArray[np.bool_] | str | None' = None, use_raw: 'bool | None' = None, groups: "Literal['all'] | Iterable[str]" = 'all', reference: 'str' = 'rest', n_genes: 'int | None' = None, rankby_abs: 'bool' = False, pts: 'bool' = False, key_added: 'str | None' = None, copy: 'bool' = False, method: '_Method | None' = None, corr_method: '_CorrMethod' = 'benjamini-hochberg', tie_correct: 'bool' = False, layer: 'str | None' = None, **kwds) -> 'AnnData | None':
    _lotus_kwargs = {}
    if mask_var is not None:
        _lotus_kwargs['mask_var'] = mask_var
    if use_raw is not None:
        _lotus_kwargs['use_raw'] = use_raw
    if groups != 'all':
        _lotus_kwargs['groups'] = groups
    if reference != 'rest':
        _lotus_kwargs['reference'] = reference
    if n_genes is not None:
        _lotus_kwargs['n_genes'] = n_genes
    if rankby_abs != False:
        _lotus_kwargs['rankby_abs'] = rankby_abs
    if pts != False:
        _lotus_kwargs['pts'] = pts
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if method is not None:
        _lotus_kwargs['method'] = method
    if corr_method != 'benjamini-hochberg':
        _lotus_kwargs['corr_method'] = corr_method
    if tie_correct != False:
        _lotus_kwargs['tie_correct'] = tie_correct
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    _lotus_kwargs.update(kwds)
    return _orig_module.rank_genes_groups(adata, groupby, **_lotus_kwargs)

def score_genes(adata: 'AnnData', gene_list: 'Sequence[str] | pd.Index[str]', *, ctrl_as_ref: 'bool' = True, ctrl_size: 'int' = 50, gene_pool: 'Sequence[str] | pd.Index[str] | None' = None, n_bins: 'int' = 25, score_name: 'str' = 'score', random_state: '_LegacyRandom' = 0, copy: 'bool' = False, use_raw: 'bool | None' = None, layer: 'str | None' = None, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if ctrl_as_ref != True:
        _lotus_kwargs['ctrl_as_ref'] = ctrl_as_ref
    if ctrl_size != 50:
        _lotus_kwargs['ctrl_size'] = ctrl_size
    if gene_pool is not None:
        _lotus_kwargs['gene_pool'] = gene_pool
    if n_bins != 25:
        _lotus_kwargs['n_bins'] = n_bins
    if score_name != 'score':
        _lotus_kwargs['score_name'] = score_name
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if use_raw is not None:
        _lotus_kwargs['use_raw'] = use_raw
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    _lotus_call_args = []
    _lotus_call_args.append(adata)
    _lotus_call_args.append(gene_list)
    return _orig_module.score_genes(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def score_genes_cell_cycle(adata: 'AnnData', *, s_genes: 'Sequence[str]', g2m_genes: 'Sequence[str]', copy: 'bool' = False, **kwargs) -> 'AnnData | None':
    _lotus_kwargs = {}
    _lotus_kwargs['s_genes'] = s_genes
    _lotus_kwargs['g2m_genes'] = g2m_genes
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_kwargs.update(kwargs)
    return _orig_module.score_genes_cell_cycle(adata, **_lotus_kwargs)

def sim(model: "Literal['krumsiek11', 'toggleswitch']" = None, *, params_file: 'bool' = True, tmax: 'int | None' = None, branching: 'bool | None' = None, nrRealizations: 'int | None' = None, noiseObs: 'float | None' = None, noiseDyn: 'float | None' = None, step: 'int | None' = None, seed: 'int | None' = None, writedir: 'Path | str | None' = None, **_lotus_extras) -> 'AnnData':
    _lotus_kwargs = {}
    if params_file != True:
        _lotus_kwargs['params_file'] = params_file
    if tmax is not None:
        _lotus_kwargs['tmax'] = tmax
    if branching is not None:
        _lotus_kwargs['branching'] = branching
    if nrRealizations is not None:
        _lotus_kwargs['nrRealizations'] = nrRealizations
    if noiseObs is not None:
        _lotus_kwargs['noiseObs'] = noiseObs
    if noiseDyn is not None:
        _lotus_kwargs['noiseDyn'] = noiseDyn
    if step is not None:
        _lotus_kwargs['step'] = step
    if seed is not None:
        _lotus_kwargs['seed'] = seed
    if writedir is not None:
        _lotus_kwargs['writedir'] = writedir
    _lotus_call_args = []
    if model is not None:
        _lotus_call_args.append(model)
    return _orig_module.sim(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def tsne(adata: 'AnnData' = None, n_pcs: 'int | None' = None, *, use_rep: 'str | None' = None, perplexity: 'float' = 30, metric: 'str' = 'euclidean', early_exaggeration: 'float' = 12, learning_rate: 'float' = 1000, random_state: '_LegacyRandom' = 0, use_fast_tsne: 'bool' = False, n_jobs: 'int | None' = None, key_added: 'str | None' = None, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if use_rep is not None:
        _lotus_kwargs['use_rep'] = use_rep
    if perplexity != 30:
        _lotus_kwargs['perplexity'] = perplexity
    if metric != 'euclidean':
        _lotus_kwargs['metric'] = metric
    if early_exaggeration != 12:
        _lotus_kwargs['early_exaggeration'] = early_exaggeration
    if learning_rate != 1000:
        _lotus_kwargs['learning_rate'] = learning_rate
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if use_fast_tsne != False:
        _lotus_kwargs['use_fast_tsne'] = use_fast_tsne
    if n_jobs is not None:
        _lotus_kwargs['n_jobs'] = n_jobs
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(n_pcs)
    return _orig_module.tsne(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def umap(adata: 'AnnData' = None, *, min_dist: 'float' = 0.5, spread: 'float' = 1.0, n_components: 'int' = 2, maxiter: 'int | None' = None, alpha: 'float' = 1.0, gamma: 'float' = 1.0, negative_sample_rate: 'int' = 5, init_pos: '_InitPos | np.ndarray | None' = 'spectral', random_state: '_LegacyRandom' = 0, a: 'float | None' = None, b: 'float | None' = None, method: "Literal['umap', 'rapids']" = 'umap', key_added: 'str | None' = None, neighbors_key: 'str' = 'neighbors', copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if min_dist != 0.5:
        _lotus_kwargs['min_dist'] = min_dist
    if spread != 1.0:
        _lotus_kwargs['spread'] = spread
    if n_components != 2:
        _lotus_kwargs['n_components'] = n_components
    if maxiter is not None:
        _lotus_kwargs['maxiter'] = maxiter
    if alpha != 1.0:
        _lotus_kwargs['alpha'] = alpha
    if gamma != 1.0:
        _lotus_kwargs['gamma'] = gamma
    if negative_sample_rate != 5:
        _lotus_kwargs['negative_sample_rate'] = negative_sample_rate
    if init_pos != 'spectral':
        _lotus_kwargs['init_pos'] = init_pos
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if a is not None:
        _lotus_kwargs['a'] = a
    if b is not None:
        _lotus_kwargs['b'] = b
    if method != 'umap':
        _lotus_kwargs['method'] = method
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if neighbors_key != 'neighbors':
        _lotus_kwargs['neighbors_key'] = neighbors_key
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.umap(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def __getattr__(name: str):
    try:
        return getattr(_orig_module, name)
    except AttributeError as exc:
        raise AttributeError(f"scanpy.tools has no attribute {name!r}") from exc

def __dir__():
    return sorted(set(__all__) | {name for name in dir(_orig_module) if not name.startswith('__')})
