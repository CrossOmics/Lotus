# Auto-generated by scripts/generate_scanpy_proxies.py
from __future__ import annotations

import inspect

import scanpy.pp as _orig_module

__all__ = [
    "calculate_qc_metrics",
    "combat",
    "downsample_counts",
    "filter_cells",
    "filter_genes",
    "filter_genes_dispersion",
    "highly_variable_genes",
    "log1p",
    "neighbors",
    "normalize_per_cell",
    "normalize_total",
    "pca",
    "recipe_seurat",
    "recipe_weinreb17",
    "recipe_zheng17",
    "regress_out",
    "sample",
    "scale",
    "scrublet",
    "scrublet_simulate_doublets",
    "sqrt",
    "subsample"
]

def calculate_qc_metrics(adata: 'AnnData' = None, *, expr_type: 'str' = 'counts', var_type: 'str' = 'genes', qc_vars: 'Collection[str] | str' = (), percent_top: 'Collection[int] | None' = (50, 100, 200, 500), layer: 'str | None' = None, use_raw: 'bool' = False, inplace: 'bool' = False, log1p: 'bool' = True, parallel: 'bool | None' = None, **_lotus_extras) -> 'tuple[pd.DataFrame, pd.DataFrame] | None':
    _lotus_kwargs = {}
    if expr_type != 'counts':
        _lotus_kwargs['expr_type'] = expr_type
    if var_type != 'genes':
        _lotus_kwargs['var_type'] = var_type
    if qc_vars != ():
        _lotus_kwargs['qc_vars'] = qc_vars
    if percent_top != (50, 100, 200, 500):
        _lotus_kwargs['percent_top'] = percent_top
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if use_raw != False:
        _lotus_kwargs['use_raw'] = use_raw
    if inplace != False:
        _lotus_kwargs['inplace'] = inplace
    if log1p != True:
        _lotus_kwargs['log1p'] = log1p
    if parallel is not None:
        _lotus_kwargs['parallel'] = parallel
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.calculate_qc_metrics(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def combat(adata: 'AnnData' = None, key: 'str' = 'batch', *, covariates: 'Collection[str] | None' = None, inplace: 'bool' = True, **_lotus_extras) -> 'np.ndarray | None':
    _lotus_kwargs = {}
    if covariates is not None:
        _lotus_kwargs['covariates'] = covariates
    if inplace != True:
        _lotus_kwargs['inplace'] = inplace
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(key)
    return _orig_module.combat(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def downsample_counts(adata: 'AnnData' = None, counts_per_cell: 'int | Collection[int] | None' = None, total_counts: 'int | None' = None, *, random_state: '_LegacyRandom' = 0, replace: 'bool' = False, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if replace != False:
        _lotus_kwargs['replace'] = replace
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(counts_per_cell)
    _lotus_call_args.append(total_counts)
    return _orig_module.downsample_counts(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def filter_cells(data: 'AnnData | CSBase | np.ndarray | DaskArray' = None, *, min_counts: 'int | None' = None, min_genes: 'int | None' = None, max_counts: 'int | None' = None, max_genes: 'int | None' = None, inplace: 'bool' = True, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | tuple[np.ndarray, np.ndarray] | None':
    _lotus_kwargs = {}
    if min_counts is not None:
        _lotus_kwargs['min_counts'] = min_counts
    if min_genes is not None:
        _lotus_kwargs['min_genes'] = min_genes
    if max_counts is not None:
        _lotus_kwargs['max_counts'] = max_counts
    if max_genes is not None:
        _lotus_kwargs['max_genes'] = max_genes
    if inplace != True:
        _lotus_kwargs['inplace'] = inplace
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    return _orig_module.filter_cells(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def filter_genes(data: 'AnnData | CSBase | np.ndarray | DaskArray' = None, *, min_counts: 'int | None' = None, min_cells: 'int | None' = None, max_counts: 'int | None' = None, max_cells: 'int | None' = None, inplace: 'bool' = True, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | tuple[np.ndarray, np.ndarray] | None':
    _lotus_kwargs = {}
    if min_counts is not None:
        _lotus_kwargs['min_counts'] = min_counts
    if min_cells is not None:
        _lotus_kwargs['min_cells'] = min_cells
    if max_counts is not None:
        _lotus_kwargs['max_counts'] = max_counts
    if max_cells is not None:
        _lotus_kwargs['max_cells'] = max_cells
    if inplace != True:
        _lotus_kwargs['inplace'] = inplace
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    return _orig_module.filter_genes(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def filter_genes_dispersion(data: 'AnnData | CSBase | np.ndarray' = None, *, flavor: "Literal['seurat', 'cell_ranger']" = 'seurat', min_disp: 'float | None' = None, max_disp: 'float | None' = None, min_mean: 'float | None' = None, max_mean: 'float | None' = None, n_bins: 'int' = 20, n_top_genes: 'int | None' = None, log: 'bool' = True, subset: 'bool' = True, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | np.recarray | None':
    _lotus_kwargs = {}
    if flavor != 'seurat':
        _lotus_kwargs['flavor'] = flavor
    if min_disp is not None:
        _lotus_kwargs['min_disp'] = min_disp
    if max_disp is not None:
        _lotus_kwargs['max_disp'] = max_disp
    if min_mean is not None:
        _lotus_kwargs['min_mean'] = min_mean
    if max_mean is not None:
        _lotus_kwargs['max_mean'] = max_mean
    if n_bins != 20:
        _lotus_kwargs['n_bins'] = n_bins
    if n_top_genes is not None:
        _lotus_kwargs['n_top_genes'] = n_top_genes
    if log != True:
        _lotus_kwargs['log'] = log
    if subset != True:
        _lotus_kwargs['subset'] = subset
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    return _orig_module.filter_genes_dispersion(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

_highly_variable_genes_max_disp_default = inspect.signature(_orig_module.highly_variable_genes).parameters['max_disp'].default

def highly_variable_genes(adata: 'AnnData' = None, *, layer: 'str | None' = None, n_top_genes: 'int | None' = None, min_disp: 'float' = 0.5, max_disp: 'float' = _highly_variable_genes_max_disp_default, min_mean: 'float' = 0.0125, max_mean: 'float' = 3, span: 'float' = 0.3, n_bins: 'int' = 20, flavor: 'HVGFlavor' = 'seurat', subset: 'bool' = False, inplace: 'bool' = True, batch_key: 'str | None' = None, check_values: 'bool' = True, **_lotus_extras) -> 'pd.DataFrame | None':
    _lotus_kwargs = {}
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if n_top_genes is not None:
        _lotus_kwargs['n_top_genes'] = n_top_genes
    if min_disp != 0.5:
        _lotus_kwargs['min_disp'] = min_disp
    if max_disp is not _highly_variable_genes_max_disp_default:
        _lotus_kwargs['max_disp'] = max_disp
    if min_mean != 0.0125:
        _lotus_kwargs['min_mean'] = min_mean
    if max_mean != 3:
        _lotus_kwargs['max_mean'] = max_mean
    if span != 0.3:
        _lotus_kwargs['span'] = span
    if n_bins != 20:
        _lotus_kwargs['n_bins'] = n_bins
    if flavor != 'seurat':
        _lotus_kwargs['flavor'] = flavor
    if subset != False:
        _lotus_kwargs['subset'] = subset
    if inplace != True:
        _lotus_kwargs['inplace'] = inplace
    if batch_key is not None:
        _lotus_kwargs['batch_key'] = batch_key
    if check_values != True:
        _lotus_kwargs['check_values'] = check_values
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.highly_variable_genes(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def log1p(data: 'AnnData | np.ndarray | CSBase' = None, *, base: 'Number | None' = None, copy: 'bool' = False, chunked: 'bool | None' = None, chunk_size: 'int | None' = None, layer: 'str | None' = None, obsm: 'str | None' = None, **_lotus_extras) -> 'AnnData | np.ndarray | CSBase | None':
    _lotus_kwargs = {}
    if base is not None:
        _lotus_kwargs['base'] = base
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if chunked is not None:
        _lotus_kwargs['chunked'] = chunked
    if chunk_size is not None:
        _lotus_kwargs['chunk_size'] = chunk_size
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if obsm is not None:
        _lotus_kwargs['obsm'] = obsm
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    return _orig_module.log1p(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

_neighbors_metric_kwds_default = inspect.signature(_orig_module.neighbors).parameters['metric_kwds'].default

def neighbors(adata: 'AnnData' = None, n_neighbors: 'int' = 15, n_pcs: 'int | None' = None, *, use_rep: 'str | None' = None, knn: 'bool' = True, method: '_Method' = 'umap', transformer: 'KnnTransformerLike | _KnownTransformer | None' = None, metric: '_Metric | _MetricFn' = 'euclidean', metric_kwds: 'Mapping[str, Any]' = _neighbors_metric_kwds_default, random_state: '_LegacyRandom' = 0, key_added: 'str | None' = None, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if use_rep is not None:
        _lotus_kwargs['use_rep'] = use_rep
    if knn != True:
        _lotus_kwargs['knn'] = knn
    if method != 'umap':
        _lotus_kwargs['method'] = method
    if transformer is not None:
        _lotus_kwargs['transformer'] = transformer
    if metric != 'euclidean':
        _lotus_kwargs['metric'] = metric
    if metric_kwds is not _neighbors_metric_kwds_default:
        _lotus_kwargs['metric_kwds'] = metric_kwds
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(n_neighbors)
    _lotus_call_args.append(n_pcs)
    return _orig_module.neighbors(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def normalize_per_cell(data: 'AnnData | np.ndarray | CSBase' = None, *, counts_per_cell_after: 'float | None' = None, counts_per_cell: 'np.ndarray | None' = None, key_n_counts: 'str' = 'n_counts', copy: 'bool' = False, layers: "Literal['all'] | Iterable[str]" = (), use_rep: "Literal['after', 'X'] | None" = None, min_counts: 'int' = 1, **_lotus_extras) -> 'AnnData | np.ndarray | CSBase | None':
    _lotus_kwargs = {}
    if counts_per_cell_after is not None:
        _lotus_kwargs['counts_per_cell_after'] = counts_per_cell_after
    if counts_per_cell is not None:
        _lotus_kwargs['counts_per_cell'] = counts_per_cell
    if key_n_counts != 'n_counts':
        _lotus_kwargs['key_n_counts'] = key_n_counts
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if layers != ():
        _lotus_kwargs['layers'] = layers
    if use_rep is not None:
        _lotus_kwargs['use_rep'] = use_rep
    if min_counts != 1:
        _lotus_kwargs['min_counts'] = min_counts
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    return _orig_module.normalize_per_cell(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def normalize_total(adata: 'AnnData' = None, *, target_sum: 'float | None' = None, exclude_highly_expressed: 'bool' = False, max_fraction: 'float' = 0.05, key_added: 'str | None' = None, layer: 'str | None' = None, inplace: 'bool' = True, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | dict[str, np.ndarray] | None':
    _lotus_kwargs = {}
    if target_sum is not None:
        _lotus_kwargs['target_sum'] = target_sum
    if exclude_highly_expressed != False:
        _lotus_kwargs['exclude_highly_expressed'] = exclude_highly_expressed
    if max_fraction != 0.05:
        _lotus_kwargs['max_fraction'] = max_fraction
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if inplace != True:
        _lotus_kwargs['inplace'] = inplace
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.normalize_total(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

_pca_mask_var_default = inspect.signature(_orig_module.pca).parameters['mask_var'].default

def pca(data: 'AnnData | np.ndarray | CSBase' = None, n_comps: 'int | None' = None, *, layer: 'str | None' = None, zero_center: 'bool' = True, svd_solver: 'SvdSolver | None' = None, chunked: 'bool' = False, chunk_size: 'int | None' = None, random_state: '_LegacyRandom' = 0, return_info: 'bool' = False, mask_var: 'NDArray[np.bool_] | str | None | Empty' = _pca_mask_var_default, use_highly_variable: 'bool | None' = None, dtype: 'DTypeLike' = 'float32', key_added: 'str | None' = None, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | np.ndarray | CSBase | None':
    _lotus_kwargs = {}
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if zero_center != True:
        _lotus_kwargs['zero_center'] = zero_center
    if svd_solver is not None:
        _lotus_kwargs['svd_solver'] = svd_solver
    if chunked != False:
        _lotus_kwargs['chunked'] = chunked
    if chunk_size is not None:
        _lotus_kwargs['chunk_size'] = chunk_size
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if return_info != False:
        _lotus_kwargs['return_info'] = return_info
    if mask_var is not _pca_mask_var_default:
        _lotus_kwargs['mask_var'] = mask_var
    if use_highly_variable is not None:
        _lotus_kwargs['use_highly_variable'] = use_highly_variable
    if dtype != 'float32':
        _lotus_kwargs['dtype'] = dtype
    if key_added is not None:
        _lotus_kwargs['key_added'] = key_added
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    _lotus_call_args.append(n_comps)
    return _orig_module.pca(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def recipe_seurat(adata: 'AnnData' = None, *, log: 'bool' = True, plot: 'bool' = False, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if log != True:
        _lotus_kwargs['log'] = log
    if plot != False:
        _lotus_kwargs['plot'] = plot
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.recipe_seurat(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def recipe_weinreb17(adata: 'AnnData' = None, *, log: 'bool' = True, mean_threshold: 'float' = 0.01, cv_threshold: 'int' = 2, n_pcs: 'int' = 50, svd_solver='randomized', random_state: '_LegacyRandom' = 0, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if log != True:
        _lotus_kwargs['log'] = log
    if mean_threshold != 0.01:
        _lotus_kwargs['mean_threshold'] = mean_threshold
    if cv_threshold != 2:
        _lotus_kwargs['cv_threshold'] = cv_threshold
    if n_pcs != 50:
        _lotus_kwargs['n_pcs'] = n_pcs
    if svd_solver != 'randomized':
        _lotus_kwargs['svd_solver'] = svd_solver
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.recipe_weinreb17(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def recipe_zheng17(adata: 'AnnData' = None, *, n_top_genes: 'int' = 1000, log: 'bool' = True, plot: 'bool' = False, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if n_top_genes != 1000:
        _lotus_kwargs['n_top_genes'] = n_top_genes
    if log != True:
        _lotus_kwargs['log'] = log
    if plot != False:
        _lotus_kwargs['plot'] = plot
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.recipe_zheng17(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def regress_out(adata: 'AnnData', keys: 'str | Sequence[str]', *, layer: 'str | None' = None, n_jobs: 'int | None' = None, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if n_jobs is not None:
        _lotus_kwargs['n_jobs'] = n_jobs
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    _lotus_call_args.append(adata)
    _lotus_call_args.append(keys)
    return _orig_module.regress_out(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def sample(data: 'AnnData | np.ndarray | CSBase | DaskArray' = None, fraction: 'float | None' = None, *, n: 'int | None' = None, rng: 'RNGLike | SeedLike | None' = None, copy: 'bool' = False, replace: 'bool' = False, axis: "Literal['obs', 0, 'var', 1]" = 'obs', p: 'str | NDArray[np.bool_] | NDArray[np.floating] | None' = None, **_lotus_extras) -> 'AnnData | None | tuple[np.ndarray | CSBase | DaskArray, NDArray[np.int64]]':
    _lotus_kwargs = {}
    if n is not None:
        _lotus_kwargs['n'] = n
    if rng is not None:
        _lotus_kwargs['rng'] = rng
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if replace != False:
        _lotus_kwargs['replace'] = replace
    if axis != 'obs':
        _lotus_kwargs['axis'] = axis
    if p is not None:
        _lotus_kwargs['p'] = p
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    _lotus_call_args.append(fraction)
    return _orig_module.sample(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def scale(data: 'AnnData | _A' = None, *, zero_center: 'bool' = True, max_value: 'float | None' = None, copy: 'bool' = False, layer: 'str | None' = None, obsm: 'str | None' = None, mask_obs: 'NDArray[np.bool_] | str | None' = None, **_lotus_extras) -> 'AnnData | _A | None':
    _lotus_kwargs = {}
    if zero_center != True:
        _lotus_kwargs['zero_center'] = zero_center
    if max_value is not None:
        _lotus_kwargs['max_value'] = max_value
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if obsm is not None:
        _lotus_kwargs['obsm'] = obsm
    if mask_obs is not None:
        _lotus_kwargs['mask_obs'] = mask_obs
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    return _orig_module.scale(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def scrublet(adata: 'AnnData' = None, adata_sim: 'AnnData | None' = None, *, batch_key: 'str | None' = None, sim_doublet_ratio: 'float' = 2.0, expected_doublet_rate: 'float' = 0.05, stdev_doublet_rate: 'float' = 0.02, synthetic_doublet_umi_subsampling: 'float' = 1.0, knn_dist_metric: '_Metric | _MetricFn' = 'euclidean', normalize_variance: 'bool' = True, log_transform: 'bool' = False, mean_center: 'bool' = True, n_prin_comps: 'int' = 30, use_approx_neighbors: 'bool | None' = None, get_doublet_neighbor_parents: 'bool' = False, n_neighbors: 'int | None' = None, threshold: 'float | None' = None, verbose: 'bool' = True, copy: 'bool' = False, random_state: '_LegacyRandom' = 0, **_lotus_extras) -> 'AnnData | None':
    _lotus_kwargs = {}
    if batch_key is not None:
        _lotus_kwargs['batch_key'] = batch_key
    if sim_doublet_ratio != 2.0:
        _lotus_kwargs['sim_doublet_ratio'] = sim_doublet_ratio
    if expected_doublet_rate != 0.05:
        _lotus_kwargs['expected_doublet_rate'] = expected_doublet_rate
    if stdev_doublet_rate != 0.02:
        _lotus_kwargs['stdev_doublet_rate'] = stdev_doublet_rate
    if synthetic_doublet_umi_subsampling != 1.0:
        _lotus_kwargs['synthetic_doublet_umi_subsampling'] = synthetic_doublet_umi_subsampling
    if knn_dist_metric != 'euclidean':
        _lotus_kwargs['knn_dist_metric'] = knn_dist_metric
    if normalize_variance != True:
        _lotus_kwargs['normalize_variance'] = normalize_variance
    if log_transform != False:
        _lotus_kwargs['log_transform'] = log_transform
    if mean_center != True:
        _lotus_kwargs['mean_center'] = mean_center
    if n_prin_comps != 30:
        _lotus_kwargs['n_prin_comps'] = n_prin_comps
    if use_approx_neighbors is not None:
        _lotus_kwargs['use_approx_neighbors'] = use_approx_neighbors
    if get_doublet_neighbor_parents != False:
        _lotus_kwargs['get_doublet_neighbor_parents'] = get_doublet_neighbor_parents
    if n_neighbors is not None:
        _lotus_kwargs['n_neighbors'] = n_neighbors
    if threshold is not None:
        _lotus_kwargs['threshold'] = threshold
    if verbose != True:
        _lotus_kwargs['verbose'] = verbose
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    _lotus_call_args.append(adata_sim)
    return _orig_module.scrublet(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def scrublet_simulate_doublets(adata: 'AnnData' = None, *, layer: 'str | None' = None, sim_doublet_ratio: 'float' = 2.0, synthetic_doublet_umi_subsampling: 'float' = 1.0, random_seed: '_LegacyRandom' = 0, **_lotus_extras) -> 'AnnData':
    _lotus_kwargs = {}
    if layer is not None:
        _lotus_kwargs['layer'] = layer
    if sim_doublet_ratio != 2.0:
        _lotus_kwargs['sim_doublet_ratio'] = sim_doublet_ratio
    if synthetic_doublet_umi_subsampling != 1.0:
        _lotus_kwargs['synthetic_doublet_umi_subsampling'] = synthetic_doublet_umi_subsampling
    if random_seed != 0:
        _lotus_kwargs['random_seed'] = random_seed
    _lotus_call_args = []
    if adata is not None:
        _lotus_call_args.append(adata)
    return _orig_module.scrublet_simulate_doublets(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def sqrt(data: 'AnnData | CSBase | np.ndarray' = None, *, copy: 'bool' = False, chunked: 'bool' = False, chunk_size: 'int | None' = None, **_lotus_extras) -> 'AnnData | CSBase | np.ndarray | None':
    _lotus_kwargs = {}
    if copy != False:
        _lotus_kwargs['copy'] = copy
    if chunked != False:
        _lotus_kwargs['chunked'] = chunked
    if chunk_size is not None:
        _lotus_kwargs['chunk_size'] = chunk_size
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    return _orig_module.sqrt(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def subsample(data: 'AnnData | np.ndarray | CSBase' = None, fraction: 'float | None' = None, *, n_obs: 'int | None' = None, random_state: '_LegacyRandom' = 0, copy: 'bool' = False, **_lotus_extras) -> 'AnnData | tuple[np.ndarray | CSBase, NDArray[np.int64]] | None':
    _lotus_kwargs = {}
    if n_obs is not None:
        _lotus_kwargs['n_obs'] = n_obs
    if random_state != 0:
        _lotus_kwargs['random_state'] = random_state
    if copy != False:
        _lotus_kwargs['copy'] = copy
    _lotus_call_args = []
    if data is not None:
        _lotus_call_args.append(data)
    _lotus_call_args.append(fraction)
    return _orig_module.subsample(*_lotus_call_args, **_lotus_kwargs, **_lotus_extras)

def __getattr__(name: str):
    try:
        return getattr(_orig_module, name)
    except AttributeError as exc:
        raise AttributeError(f"scanpy.pp has no attribute {name!r}") from exc

def __dir__():
    return sorted(set(__all__) | {name for name in dir(_orig_module) if not name.startswith('__')})
